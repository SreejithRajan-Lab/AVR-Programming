/* atmega328p_sh1106_lm35.c
 * Bare-metal LM35 temperature display on 1.3" SH1106 I2C OLED (IIC v2.2)
 * MCU: ATmega328P @ 16 MHz
 * I2C: ~100 kHz
 * OLED address: 0x3C (change to 0x3D if your scanner says so)
 * LM35 on PC0 (ADC0). AVcc=5V reference => T(°C) ~= ADC * 500 / 1023
 */

#define F_CPU 16000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- OLED config -----------------
#define OLED_ADDR 0x3C           // 7-bit I2C address (0x3C or 0x3D)
#define SH1106_COL_OFFSET 2      // SH1106 visible area starts at column 2

// ---------- Minimal 5x7 ASCII font (96 chars: 0x20..0x7F) ----------
static const uint8_t font5x7[96][5] = {
  {0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x5F,0x00,0x00},{0x00,0x07,0x00,0x07,0x00},{0x14,0x7F,0x14,0x7F,0x14},{0x24,0x2A,0x7F,0x2A,0x12},
  {0x23,0x13,0x08,0x64,0x62},{0x36,0x49,0x55,0x22,0x50},{0x00,0x05,0x03,0x00,0x00},{0x00,0x1C,0x22,0x41,0x00},{0x00,0x41,0x22,0x1C,0x00},
  {0x14,0x08,0x3E,0x08,0x14},{0x08,0x08,0x3E,0x08,0x08},{0x00,0x50,0x30,0x00,0x00},{0x08,0x08,0x08,0x08,0x08},{0x00,0x60,0x60,0x00,0x00},{0x20,0x10,0x08,0x04,0x02},
  {0x3E,0x51,0x49,0x45,0x3E},{0x00,0x42,0x7F,0x40,0x00},{0x42,0x61,0x51,0x49,0x46},{0x21,0x41,0x45,0x4B,0x31},{0x18,0x14,0x12,0x7F,0x10},
  {0x27,0x45,0x45,0x45,0x39},{0x3C,0x4A,0x49,0x49,0x30},{0x01,0x71,0x09,0x05,0x03},{0x36,0x49,0x49,0x49,0x36},{0x06,0x49,0x49,0x29,0x1E},
  {0x00,0x36,0x36,0x00,0x00},{0x00,0x56,0x36,0x00,0x00},{0x08,0x14,0x22,0x41,0x00},{0x14,0x14,0x14,0x14,0x14},{0x00,0x41,0x22,0x14,0x08},{0x02,0x01,0x51,0x09,0x06},
  {0x32,0x49,0x79,0x41,0x3E},{0x7E,0x11,0x11,0x11,0x7E},{0x7F,0x49,0x49,0x49,0x36},{0x3E,0x41,0x41,0x41,0x22},{0x7F,0x41,0x41,0x22,0x1C},
  {0x7F,0x49,0x49,0x49,0x41},{0x7F,0x09,0x09,0x09,0x01},{0x3E,0x41,0x49,0x49,0x7A},{0x7F,0x08,0x08,0x08,0x7F},{0x00,0x41,0x7F,0x41,0x00},
  {0x20,0x40,0x41,0x3F,0x01},{0x7F,0x08,0x14,0x22,0x41},{0x7F,0x40,0x40,0x40,0x40},{0x7F,0x02,0x0C,0x02,0x7F},{0x7F,0x04,0x08,0x10,0x7F},
  {0x3E,0x41,0x41,0x41,0x3E},{0x7F,0x09,0x09,0x09,0x06},{0x3E,0x41,0x51,0x21,0x5E},{0x7F,0x09,0x19,0x29,0x46},{0x46,0x49,0x49,0x49,0x31},{0x01,0x01,0x7F,0x01,0x01},
  {0x3F,0x40,0x40,0x40,0x3F},{0x1F,0x20,0x40,0x20,0x1F},{0x3F,0x40,0x38,0x40,0x3F},{0x63,0x14,0x08,0x14,0x63},{0x07,0x08,0x70,0x08,0x07},{0x61,0x51,0x49,0x45,0x43},
  {0x00,0x7F,0x41,0x41,0x00},{0x02,0x04,0x08,0x10,0x20},{0x00,0x41,0x41,0x7F,0x00},{0x04,0x02,0x01,0x02,0x04},{0x80,0x80,0x80,0x80,0x80},{0x00,0x03,0x07,0x00,0x00},
  {0x20,0x54,0x54,0x54,0x78},{0x7F,0x48,0x44,0x44,0x38},{0x38,0x44,0x44,0x44,0x20},{0x38,0x44,0x44,0x48,0x7F},{0x38,0x54,0x54,0x54,0x18},{0x08,0x7E,0x09,0x01,0x02},
  {0x0C,0x52,0x52,0x52,0x3E},{0x7F,0x08,0x04,0x04,0x78},{0x00,0x44,0x7D,0x40,0x00},{0x20,0x40,0x44,0x3D,0x00},{0x7F,0x10,0x28,0x44,0x00},{0x00,0x41,0x7F,0x40,0x00},
  {0x7C,0x04,0x18,0x04,0x78},{0x7C,0x08,0x04,0x04,0x78},{0x38,0x44,0x44,0x44,0x38},{0x7C,0x14,0x14,0x14,0x08},{0x08,0x14,0x14,0x14,0x7C},{0x7C,0x08,0x04,0x04,0x08},
  {0x48,0x54,0x54,0x54,0x20},{0x04,0x3F,0x44,0x40,0x20},{0x3C,0x40,0x40,0x20,0x7C},{0x1C,0x20,0x40,0x20,0x1C},{0x3C,0x40,0x30,0x40,0x3C},{0x44,0x28,0x10,0x28,0x44},
  {0x0C,0x50,0x50,0x50,0x3C},{0x44,0x64,0x54,0x4C,0x44},{0x00,0x08,0x36,0x41,0x00},{0x00,0x00,0x7F,0x00,0x00},{0x00,0x41,0x36,0x08,0x00},{0x10,0x08,0x08,0x10,0x08},{0x00,0x00,0x00,0x00,0x00}
};

// ----------------- I2C (TWI) -----------------
static void i2c_init(void) {
  TWSR = 0x00;              // prescaler = 1
  TWBR = 72;                // ~100 kHz @ 16 MHz
  TWCR = (1<<TWEN);         // enable TWI
}

static void i2c_start(void) {
  TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
  while (!(TWCR & (1<<TWINT)));
}

static void i2c_stop(void) {
  TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
}

static void i2c_write(uint8_t data) {
  TWDR = data;
  TWCR = (1<<TWINT)|(1<<TWEN);
  while (!(TWCR & (1<<TWINT)));
}

// ----------------- SH1106 low-level -----------------
static void sh1106_cmd(uint8_t c) {
  i2c_start();
  i2c_write((OLED_ADDR<<1) | 0);
  i2c_write(0x00);    // Co=0, D/C#=0 (command)
  i2c_write(c);
  i2c_stop();
}

static void sh1106_cmd2(uint8_t c1, uint8_t c2) {
  i2c_start();
  i2c_write((OLED_ADDR<<1) | 0);
  i2c_write(0x00);
  i2c_write(c1);
  i2c_write(c2);
  i2c_stop();
}

static void sh1106_data_begin(void) {
  i2c_start();
  i2c_write((OLED_ADDR<<1) | 0);
  i2c_write(0x40);    // Co=0, D/C#=1 (data)
}
static void sh1106_data_byte(uint8_t d) { i2c_write(d); }
static void sh1106_data_end(void) { i2c_stop(); }

static void sh1106_set_page(uint8_t page) { sh1106_cmd(0xB0 | (page & 0x07)); }
static void sh1106_set_col(uint8_t col) {
  uint8_t c = col + SH1106_COL_OFFSET;
  sh1106_cmd(0x10 | (c >> 4));
  sh1106_cmd(0x00 | (c & 0x0F));
}

static void sh1106_init(void) {
  _delay_ms(50);
  sh1106_cmd(0xAE);                // display off
  sh1106_cmd2(0xD5, 0x80);         // clock
  sh1106_cmd2(0xA8, 0x3F);         // multiplex 1/64
  sh1106_cmd2(0xD3, 0x00);         // offset
  sh1106_cmd(0x40);                // start line
  sh1106_cmd(0xA1);                // segment remap
  sh1106_cmd(0xC8);                // COM scan direction
  sh1106_cmd2(0xDA, 0x12);         // COM pins
  sh1106_cmd2(0x81, 0x80);         // contrast
  sh1106_cmd2(0xD9, 0xF1);         // precharge
  sh1106_cmd2(0xDB, 0x40);         // VCOMH
  sh1106_cmd2(0xAD, 0x8B);         // DC-DC on (SH1106)
  sh1106_cmd(0xA4);                // resume RAM
  sh1106_cmd(0xA6);                // normal display
  sh1106_cmd(0xAF);                // display on
}

static void sh1106_clear(void) {
  for (uint8_t p = 0; p < 8; p++) {
    sh1106_set_page(p);
    sh1106_set_col(0);
    sh1106_data_begin();
    for (uint8_t i = 0; i < 128; i++) sh1106_data_byte(0x00);
    sh1106_data_end();
  }
}

// ----------------- 5x7 text drawing -----------------
static void draw_char(uint8_t x, uint8_t page, char c) {
  if (c < 32 || c > 127) c = '?';
  const uint8_t *col = font5x7[c - 32];
  sh1106_set_page(page);
  sh1106_set_col(x);
  sh1106_data_begin();
  for (uint8_t i = 0; i < 5; i++) sh1106_data_byte(col[i]);
  sh1106_data_byte(0x00); // 1px space
  sh1106_data_end();
}

static void draw_str(uint8_t x, uint8_t page, const char *s) {
  while (*s && x <= 122) {
    draw_char(x, page, *s++);
    x += 6;
  }
}

// ----------------- ADC (LM35 on ADC0 / PC0) -----------------
static void adc_init(void) {
  ADMUX  = (1<<REFS0);             // AVcc as reference, ADC0 selected
  ADCSRA = (1<<ADEN)               // enable ADC
         | (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); // prescaler 128 -> 125kHz ADC clock
  DIDR0 |= (1<<ADC0D);             // disable digital input on ADC0
}

static uint16_t adc_read_once(void) {
  ADCSRA |= (1<<ADSC);             // start conversion
  while (ADCSRA & (1<<ADSC));      // wait
  return ADC;                      // 10-bit result
}

// Average N samples to reduce noise
static uint16_t adc_read_avg(uint8_t N) {
  uint32_t acc = 0;
  for (uint8_t i=0;i<N;i++) {
    acc += adc_read_once();
  }
  return (uint16_t)(acc / N);
}

// Convert ADC to tenths of °C using integer math:
// T(0.1°C) = ADC * 5000 / 1023  (since 5.0V * 100°C/V * 10 / 1023)
static uint16_t lm35_read_tenthsC(void) {
  uint16_t adc = adc_read_avg(16);
  uint32_t t10 = (uint32_t)adc * 5000u + 511u; // +511 for rounding
  t10 /= 1023u;
  if (t10 > 2000u) ; // no-op; just guard if you want to clip
  return (uint16_t)t10;
}

// Format "XX.X C" into buf (must be >= 8 bytes)
static void format_temp(char *buf, uint16_t t10) {
  uint16_t whole = t10 / 10;
  uint8_t frac = t10 % 10;

  // Convert whole to string
  char tmp[6]; // up to "1023\0"
  itoa(whole, tmp, 10);

  // Build "NNN.N C"
  char *p = buf;
  for (char *q = tmp; *q; ++q) *p++ = *q;
  *p++ = '.';
  *p++ = '0' + frac;
  *p++ = ' ';
  *p++ = 'C';
  *p   = '\0';
}

// ----------------- Main -----------------
int main(void) {
  i2c_init();
  sh1106_init();
  sh1106_clear();

  adc_init();

  // Title
  draw_str(0, 0, "LM35 Temperature");

  char line[16];

  for (;;) {
    uint16_t t10 = lm35_read_tenthsC();   // tenths of °C
    format_temp(line, t10);               // e.g., "27.4 C"

    // Clear the area (page 2) by writing spaces across ~10 chars
    // (Optional: full-screen clear is costlier)
    for (uint8_t i=0;i<10;i++) draw_char(6*i, 2, ' ');

    // Draw temp starting at x=0, page=2
    draw_str(0, 2, line);

    _delay_ms(250);
  }
}
